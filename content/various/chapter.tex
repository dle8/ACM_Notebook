\chapter{Various}

\section{Intervals}
	\kactlimport{IntervalContainer.h}
	\kactlimport{IntervalCover.h}
	\kactlimport{ConstantIntervals.h}

\section{TernarySearch}
	\kactlimport{TernarySearch.h}
	% \kactlimport{LIS.h}

\section{Dynamic programming}
	\kactlimport{KnuthDP.h}
	\kactlimport{DivideAndConquerDP.h}
    \subsection{DP Optimizations}
        \begin{itemize}
            \item Convex Hull Optimization1.
                  $dp[i]=min_{j<i} \{dp[j]+b[j]\cdot a[i]\}$
                  Condition: $b[j] \geq b[j + 1] \textbf{and} a[i]\leq a[i+1]$.
                  From $O(n^2)$ to $O(n)$. Technique: Convex-hull trick, query of linear functions, Li chao tree. Ask Vlad.
            \item Convex Hull Optimization2.
                  $dp[i][j] = min_{k<j}\{dp[i-1][k]+b[k]\cdot a[j]\}$.
                  Condition: $b[k] \geq b[k+1] \textbf{and} a[j] \leq a[j+1]$.
                  From $O(kn^2)$ to $O(kn)$. Technique: Same as before. Ask Vlad
            \item Divide and Conquer Optimization
                  $dp[i][j] = min_{k<j} \{ dp[i-1][k] + C[k][j] \} $
                  Condition: $A[i][j] \leq A[i][j + 1]$
                  From $O(kn^2)$ to $O(kn logn)$. Technique: in notebook.
            \item Knuth optimization
                  $dp[i][j] = min_{i<k<j} \{ dp[i][k] + dp[k][j] \} + C[i][j]$
                  Condition: $A[i][j-1] \leq A[i][j] \leq A[i + 1][j]$.
                  From $O(n^3)$ to $O(n^2)$. Technique: Solve $dp[i][j]$ in increasing order of $j-i$.
        \end{itemize}


% \section{Debugging tricks}
% 	\begin{itemize}
% 		\item \verb@signal(SIGSEGV, [](int) { _Exit(0); });@ converts segfaults into Wrong Answers.
% 			Similarly one can catch SIGABRT (assertion failures) and SIGFPE (zero divisions).
% 			\verb@_GLIBCXX_DEBUG@ failures generate SIGABRT (or SIGSEGV on gcc 5.4.0 apparently).
% 		\item \verb@feenableexcept(29);@ kills the program on NaNs (\texttt 1), 0-divs (\texttt 4), infinities (\texttt 8) and denormals (\texttt{16}).
% 	\end{itemize}

\section{Pick's Theorem}
	\begin{itemize}
		\item Pick's Theorem is a useful method for determining the area of any polygon whose vertices are points on a lattice, a regularly spaced array of points. While lattices may have points in different arrangements, this essay uses a square lattice to examine Pick's Theorem.
		\item Boundary Point (B): a lattice point on the polygon (including vertices)
		\item Interior Point (I): a lattice point in the polygonâ€™s interior region
		\item Area = B / 2 + I - 1
	\end{itemize}

\section{Optimization tricks}
	\subsection{Bit hacks}
		\begin{itemize}
			\item \verb@x & -x@ is the least bit in \texttt{x}.
			\item \verb@for (int x = m; x; ) { --x &= m; ... }@ loops over all subset masks of \texttt{m} (except \texttt{m} itself).
			\item \verb@c = x&-x, r = x+c; (((r^x) >> 2)/c) | r@ is the next number after \texttt{x} with the same number of bits set.
			\item \verb@rep(b,0,K) rep(i,0,(1 << K))@ \\ \verb@  if (i & 1 << b) D[i] += D[i^(1 << b)];@ computes all sums of subsets.
		\end{itemize}
	\subsection{Pragmas}
		\begin{itemize}
			\item \lstinline{#pragma GCC optimize ("Ofast")} will make GCC auto-vectorize for loops and optimizes floating points better (assumes associativity and turns off denormals).
			\item \lstinline{#pragma GCC target ("avx,avx2")} can double performance of vectorized code, but causes crashes on old machines.
			\item \lstinline{#pragma GCC optimize ("trapv")} kills the program on integer overflows (but is really slow).
		\end{itemize}
	\kactlimport{FastMod.h}
	% \kactlimport{FastInput.h}
	\kactlimport{Unrolling.h}
